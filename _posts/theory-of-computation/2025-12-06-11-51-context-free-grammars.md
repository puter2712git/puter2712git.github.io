---
title: Context-Free Grammars
date: 2025-12-06 11:51:00 +0900
categories: [Theory of Computation]
tags: ["Learning", "Theory of Computation"]
pin: true
math: true
mermaid: true
---

## Context-Free Grammars (CFGs)

앞서 살펴본 rewriting을 이용해서, **Context-Free Grammars**라고 알려진 특정 rewriting system을 정의할 수 있습니다. CFGs는 regular expression보다 powerful하고, programming languages와 compiler construction에 매우 중요합니다.

> Let $\sum = \{a, b\}$. Then, $L(a(a^{\ast} + b^{\ast})b)$ can be generated by the following productions: <br>
> - $S \to aMb$: $S$ begins with $a$ and ends with $b$ and has a middle part $M$.
> - $M \to A$: The middle part can be a string $A$ of $a$'s
> - $M \to B$: or a string $B$ of $b$'s
> - $A \to \lambda$: $A$ string of $a$'s can be the null string
> - $A \to aA$: or an a followed by a string of $a$'s.
> - $B \to \lambda$: $A$ string of $b$'s can be the null string
> - $B \to bB$: or a $b$ followed by a string of $b$'s.

---

Context-free grammar $G$는 $(V, T, P, S)$ tuple로 정의됩니다.
- $V$는 **variables**(**nonterminals**)의 finite set
- $T$는 **terminals**의 finite set
- $P \subseteq V \times (V \cup T)^{*}$는 **productions**의 finite set
- $S \in V$는 **start symbol**(or sentence symbol)

> Let $\sum = \{a, b\}$. Then, $L(a(a^{\ast} + b^{\ast})b)$ can be generated by the following grammar $G = (V, T, P, S)$, where
> - $V = \lbrace A, B, M, S \rbrace$
> - $T = \lbrace a, b \rbrace$
> - $P = \lbrace S \to aMb, M \to A \vert B, A \to \lambda \vert aA, B \to \lambda \vert bB \rbrace$

---

### Examples

$G = (V, T, P, S)$, where $V = \lbrace S \rbrace$, $T = \lbrace a, \; b \rbrace$ and $P = \lbrace S \to aSb \; \vert \; \lambda \rbrace$

위 grammar로 만들어지는 language는 $a$와 $b$가 같은 string의 집합입니다.

$G = (V, T, P, S)$, where $V = \lbrace S \rbrace$, $T = \lbrace a, \; b \rbrace$ and $P = \lbrace S \to aSb \; \vert \; aS \; \vert \; \lambda \rbrace$

위 grammar로 만들어지는 language는 $a$의 개수가 $b$의 개수보다 크거나 같은 string의 집합입니다.

$G = (\lbrace E \rbrace, \; \lbrace 0, \; 1, \; (, \; ), \; +, \; \cdot, \; \ast \rbrace, \; P, \; E)$, where $P = \lbrace E \to 0 \; \vert \; 1 \; \vert \; E \cdot E \; \vert \; E + E \; \vert \; E^{\ast} \; \vert \; (E) \rbrace$

위 grammar로 만들어지는 language는 regular expression을 나타내는 string의 집합입니다.

---

## CFGs: Derivations

CFG는 rewriting(derivation)을 통해 string을 생성합니다:
- 만약 $A \to u$이고 $x, \; y \in \lbrace V \cup T \rbrace^{\ast}$ 이면, $xAy \implies xuy$ 로 쓸 수 있습니다.
- 만약 $w_{0} \implies w_{1} \implies w_{2} \implies w_{3} \implies \cdots \implies w_{n}$ 이면, $w_{0} \overset{\ast}\implies w_{n}$ 로 쓸 수 있습니다.
- CFG는 어떤 symbol이 다른 symbol로 변할 때, 그 옆에 어떤 symbol이 오든 상관하지 않습니다. 이런 특징 때문에 CFG를 **context-free**하다고 합니다.
- 정의에 따라, $u \in \lbrace V \cup T \rbrace^{\ast}$ 이면, $u \overset{\ast}{\implies} u$가 성립합니다.
- $w_{0} \implies w_{1} \implies w_{2} \implies w_{3} \implies \cdots \implies w_{n}$, $w_{0} \overset{\ast}{\implies} w_{n}$ 를 $G$의 $w_{0}$ 로부터의 $w_{n}$의 **derivation**이라고 부르고, **derivation length**는 $n$입니다.
- $G$의 **language** $L(G)$는 **start symbol**로 derived 될 수 있는 모든 **terminal strings**의 집합입니다: $\lbrace w \in T^{\ast} \; \vert \; S \overset{\ast}\implies w \rbrace$
- 만약 language가 **context-free grammar**로 구성됐다면 이는 **context-free-language**(CFL)입니다.

---

**Leftmost derivation** $\underset{\text{lm}}\implies$ 이란 항상 leftmost variable부터 하나씩 replace하는 것입니다.

$$
E \underset{\text{lm}}\implies E + E \underset{\text{lm}}\implies 0 + E \underset{\text{lm}}\implies 0 + (E) \underset{\text{lm}}\implies 0 + (E \cdot E)
$$
$$
\underset{\text{lm}}\implies 0 + (1 \cdot E) \underset{\text{lm}}\implies 0 + (1 \cdot 0)
$$

**Rightmost derivation** $\underset{\text{rm}}\implies$ 이란 항상 rightmost variable부터 하나씩 replace하는 것입니다.

$$
E \underset{\text{rm}}\implies E + E \underset{\text{rm}}\implies E + (E) \underset{\text{rm}}\implies E + (E \cdot E) \underset{\text{rm}}\implies E + (E \cdot 0)
$$
$$
\underset{\text{rm}}\implies E + (1 \cdot 0) \underset{\text{rm}}\implies 0 + (1 \cdot 0)
$$

---

$G = (V, T, P, S)$가 CFG이고 $\alpha \in (V \cup T)^{\ast}$라고 정의합니다. 만약

$$
S \overset{\ast}\implies \alpha
$$

이면, $\alpha$ 를 **sentential form**이라고 합니다. <br>
만약 $S \overset{\ast}{\underset{\text{lm}}\implies} \alpha$ 이면, $\alpha$ 를 **left-sentential form**이라고 부르고, $S \overset{\ast}{\underset{\text{rm}}\implies} \alpha$ 이면, $\alpha$ 를 **right-sentential form**이라고 부릅니다.

$L(G)$ 는 $T^{\ast}$ 에 속하는 **sentential forms**입니다. (terminal로 이루어진 문자열 집합)

---

String은 두 개나 그 이상의 다른 derivation을 가질 수 있습니다:

$$
S \implies SS \implies (S)S \implies (S)(S) \implies ((S))(S) \implies (())(S) \implies (())()
$$

$$
S \implies SS \implies S(S) \implies S() \implies (S)() \implies ((S))() \implies (())()
$$

**Parse tree**(syntax tree)를 통해 나타내면 위의 두 개의 derivation도 유일하게 나타납니다. Parse tree는 production order에 무관하게 derivation을 나타냅니다.

![parse tree](/assets/parse-tree.png)

- **Internal node**: children을 가지는 node
- **External node**: children을 가지지 않는 node
- **Frontier**: external node들의 left-to-right sequence
- **Yield**: frontier에 의해 정의되는 string (위 parse tree에서는 **(())()**가 yield)
- **Internal node**는 nonterminals로 표기되고, **external node**는 terminals, nonterminals, $\lambda$로 표기됩니다.

---

CFG $G$ 와 $G$의 variable $A$ 가 주어질 때, 다음의 모든 statement는 모두 equivalent합니다.
- $A \overset{\ast}\implies w$
- $A \overset{\ast}{\underset{\text{lm}}\implies} w$
- $A \overset{\ast}{\underset{\text{rm}}\implies} w$
- $A$를 root로 하고 $w$를 yield하는 parse tree가 존재합니다.

**Context-Freeness**: If $X \overset{\ast}\implies \gamma$ , then $\alpha X \beta \overset{\ast}\implies \alpha \gamma \beta$ .

1. 만약 CFG $G$에 대해 $w \in L(G)$ 이면, $w$는 **parse tree**를 가집니다. 이 parse tree는 $w$의 structure를 나타냅니다.
2. $w$는 SQL-query나 XML document일 수도 있습니다.
3. Parse tree는 derivation의 또다른 표현 방식입니다.
4. 같은 string에 대해 여러 parse tree가 존재할 수 있습니다.
5. 이상적으로는 각 string에 대해 오직 하나의 parse tree만 존재해야 합니다. 즉 language는 **unambiguous** 해야 합니다.
6. 하지만 우리는 항상 ambiguity를 제거할 수 없습니다.

---

$$
E \to I \; \vert \; E + E \; \vert \; E * E \; \vert \; (E)
$$

위 grammar에서 sentential form $E + E * E$ 는 두 가지 derivation을 가집니다.

$$
E \Rightarrow E + E \Rightarrow E + E * E
$$

$$
E \Rightarrow E * E \Rightarrow E + E * E
$$

이는 하나의 string에 대해 서로 다른 두 개의 parse tree를 만듭니다. 즉, 이 grammar는 **ambiguous**합니다.

---

$G = (V, T, P, S)$ 를 CFG라고 둡니다. 만약 $L(G)$ 의 하나의 string이라도 두 개 이상의 서로 다른 parse tree를 갖는다면 $G$ 를 **ambiguous**하다고 정의합니다. 만약 $L(G)$ 의 모든 string이 하나의 parse tree만을 가진다면 $G$ 를 **unambiguous**하다고 정의합니다.

우리는 특정 경우에 손수 ambiguity를 제거할 수는 있지만, 이와 관련된 algorithm은 존재하지 않습니다. 추가로 몇몇 CFL은 ambiguous CFG만을 가지는 경우도 존재합니다.

$$
E \to I \;\vert\; E + E \;\vert\; E * E \;\vert\; (E)
$$

$$
I \to a \;\vert\; b \;\vert\; Ia \;\vert\; Ib \;\vert\; I0 \;\vert\; I1
$$

위 grammar에는 두 가지 문제가 존재합니다:
- *과 + 사이 precedence가 존재하지 않습니다.
- operator의 sequence에 grouping이 존재하지 않습니다: $E + E + E$ 가 $E + (E + E)$ 인지 $(E + E) + E$ 인지 알 수 없습니다.

---

## Removing Ambiguity

먼저 variables를 추가로 더 나타내는 방법을 소개하겠습니다:
- **Factor**는 인접한 * 또는 +에 의해 떨어져 나가지 않는 expression입니다.
- **Term**은 +에 의해 쪼개지지 않는 expression입니다.
- **Expression**은 *로도, +로도 쪼개질 수 있는 expression입니다.

$F$ 가 factors, $T$ 가 terms, $E$ 를 expressions라고 둡니다.

- $I \to a \;\vert\; b \;\vert\; Ia \;\vert\; Ib \;\vert\; I0 \;\vert\; I1$
- $F \to I \;\vert\; (E)$
- $T \to F \;\vert\; T * F$
- $E \to T \;\vert\; E + T$
- $I \to a \;\vert\; b \;\vert\; Ia \;\vert\; Ib \;\vert\; I0 \;\vert\; I1$


위와 같은 grammar에서는 $a + a * a$ 가 유일한 parse tree를 가집니다.

---

만약 CFL $L$ 에 대한 모든 grammar가 ambiguous하다면 $L$ 을 **inherently ambiguous**라고 정의합니다.

다음과 같은 language $L$은 inherently ambiguous합니다.

$$
L = \lbrace a^{n}b^{n}c^{m}d^{m} \;\vert\; n \ge 1,\; m \ge 1 \rbrace \cup \lbrace a^{n}b^{m}c^{m}d^{n} \;\vert\; n \ge 1, \; m \ge 1 \rbrace
$$

위 language를 위한 grammar는 다음과 같습니다.
- $S \to AB \;\vert\; C$
- $A \to aAb \;\vert\; ab$
- $B \to cBd \;\vert\; cd$
- $C \to aCd \;\vert\; aDd$
- $D \to bDc \;\vert\; bc$

위 language에서, 우리는 두 가지의 leftmost derivations를 찾을 수 있습니다.

$$
S \underset{\text{lm}}\implies AB \underset{\text{lm}}\implies aAbB \underset{\text{lm}}\implies aabbB \underset{\text{lm}}\implies aabbcBd \underset{\text{lm}}\implies aabbccdd
$$

$$
S \underset{\text{lm}}\implies C \underset{\text{lm}}\implies aCd \underset{\text{lm}}\implies aaDdd \underset{\text{lm}}\implies aabDcdd \underset{\text{lm}}\implies aabbccdd
$$

Language $L$은 구조적으로 다른 language 두 개의 합집합으로 이루어지게 되는데, 이 이유는 $a^{k}b^{k}c^{k}d^{k}$ 와 같은 교집합을 이루는 string이 근본적으로 다른 구조로 해석되도록 강제되기 때문에 발생합니다.