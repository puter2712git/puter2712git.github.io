---
title: TCP
date: 2025-11-29
categories: [Computer Network]
tags: ["Computer Network"]
pin: true
math: true
mermaid: true
---

## Connection Oriented

**Circuit switching**은 **connection-oriented**한 통신 방식 중 하나입니다. 회선 교환은 다음과 같은 세 가지 단계로 이루어집니다.
- Circuit Establishment: 송신자와 수신자 사이에 회선이 생성됩니다.
- Data Transfer: 생성된 회선을 통해 데이터를 이동시킵니다.
- Circuit Disconnect: 통신이 완료되면 회선이 해제됩니다.

회선은 한번 설정되면 transfer는 transparent합니다.
- no transmission delay
- no delay variation
- no loss

이러한 회선 교환은 본래 음성 통신을 위해 개발되었습니다. (**실시간성**과 **일정한 지연**)

---

**Datagram packet switching**은 위의 통신 방식과 대비되는 **connectionless** 방식으로, 현대 인터넷의 근간이 되는 방식입니다.

**Packet**은 데이터의 단위로, 독립적으로 처리됩니다.
- packet은 어느 경로로든 전송 가능 (각 packet마다 서로 다른 route를 통해 이동)
- 각 packet마다 routing decision 필요
- packet의 순서가 뒤바뀔 수 있음
- packet이 손실될 수 있음

**Link**는 여러 connection들 사이에서 공유됩니다.
- congestion이 발생할 수 있음
    - packet delay 길어짐
    - packet 손실

---

**Connection-oriented**한 통신으로 다음과 같은 예시가 있습니다.
- Telephone Network
    - phone과 phone 사이 물리적인 회선 연결
    - 메시지를 전달할 때 acknowledgement 없음

- **TCP**
    - end-to-end host 사이 물리적 연결 없음
    - 다만 메시지를 전달할 때 acknowledgement로 확인

즉, **connection-oriented**한 통신 방식이란 내가 보낸 메시지가 수신자에게 정상적으로 도착했는지를 확인할 수 있는 통신 방식입니다.

---

**TCP**는 앞서 말했듯 connection-oriented하고, 세 가지 단계로 통신이 이루어집니다.
- connection establishment
- data transfer
- connection termination

**TCP Connection**은 client와 server 사이 positive ACK mechanism을 통한 relationship으로 구성됩니다. (물리적 연결 없음)

---

**Transport Layer**는 크게 두 가지로 나뉘어집니다: **TCP**, **UDP**

TCP와 UDP의 공통점:
- port number로 application 구분 (multiplexing, demultiplexing)
- 에러 감지 (checksum)

TCP만의 특징:
- segmentation과 reassembly
- tracking individual communications between applications (stateful session management)
- conversations 제어
    - session 설정 (3-way handshake)
    - reliable delivery (ARQ를 통한 데이터 누락 방지)
    - same order delivery (sequence number를 통해 순서 보쟝)
    - flow control
- congestion control (네트워크 자원 과부하를 막고 성능 저하를 방지)

---

TCP는 다음과 같은 여섯 가지 주요 특징이 존재합니다.
- connection-oriented: 데이터 교환 전에 three-way handshake로 연결 설정
- reliable, in-order byte stream: no **message boundaries** (연속된 바이트로 전송)
- point-to-point: 하나의 sender는 오직 하나의 receiver와 쌍을 이룸 (multicasting이 허용되지 않음)
- full duplex service: 하나의 연결에서 양방향 데이터 flow
- pipelined: ACK를 기다리지 않고 여러 segment를 연속적으로 전송 (GBN & SR)
- flow controlled: sender가 receiver가 데이터를 처리하는 속도 이상으로 전송하지 않음 (not overwhelm)

---

## Segmentation and Reassembly

**MTU**(Maximum Transmission Unit): NIC가 처리할 수 있는 link-layer frame payload의 최대 크기 <br>
(IP header, TCP header, application data를 포함)

**MSS**(Maximum Segmentation Unit): segment의 application-layer data의 최대 크기 <br>
(a TCP segment = TCP header + segmented data at maximum of MSS)

따라서 MSS는 MTU에서 TCP & IP header의 길이를 뺀 것과 같습니다. <br>
> example: <br>
> MTU for Ethernet = $1500 \text{ byte}$, typical IP and TCP headers = $20 \text{ bytes both}$ <br>
> MSS = MTU - (TCP&IP header) = $1500 - 40 = 1460$

---

하지만 우리가 전송하는 application data의 크기는 MSS보다 큰 경우가 많습니다. (movie, image, etc.) 따라서 **segmentation**과 **reassembly** 방식을 통해 데이터를 교환합니다. <br>

Sender에서는 MSS에 맞춰 데이터를 나누고, 각 조각에 sequence number를 header로 추가합니다. (segmetation)

Receiver에서는 sequence number를 이용해서 조각들을 기존 데이터 순서대로 합칩니다. (reassembly)

> UDP에서는 UDP diagram의 payload size와 data의 크기가 동일하고, segmentation과 assembly가 따로 존재하지 않습니다.

---

**Sequence number**는 segment의 첫 번째 byte를 식별해서 얻습니다. 이를 통해 해당 segment가 데이터의 몇 번째 조각에 해당하는지 알 수 있습니다.

**Acknowledgement number**는 예상되는 다음 byte의 sequence number입니다. TCP는 **cumulative ACK** 방식을 사용합니다.

> Cumulative ACK: 가장 마지막으로 순서대로 도착한 데이터까지의 범위를 알려줌

---

**Piggybacking**은 TCP에서 데이터 통신에 사용되는 기법 중 하나로, 수신자가 ACK number를 송신자에게 보낼 때 만약 따로 전달해야 할 데이터가 있다면 함께 실어서 보내는 방식입니다. 이는 TCP throughput performance를 높이는 효과를 가져옵니다.

---

## Round-Trip Time (RTT)

**Round-Trip Time**(RTT)는 segment가 전송됐을 때의 시간과 해당되는 ACK를 받았을 때까지의 time interval입니다. 이 값을 통해 ARQ에서 사용하는 timeout를 계산합니다.

따라서 TCP timeout 값은 RTT보다는 길어야 하고, 적절하게 설정해야 합니다. 또는 동적으로 계산되어질 수 있습니다. (네트워크 상황에 따라 RTT가 달라지므로)

너무 짧은 timeout을 설정하는 경우:
- premature timeout (너무 이르게 timeout이 발동)
- unnecessary retransmissions

너무 긴 timeout을 설정하는 경우:
- segment loss가 발생했을 때 반응이 느림
- 불필요한 대기 시간 생김

---

RTT를 계산하기 위해 TCP는 **EWMA** (Exponential Weighted Moving Average)를 사용합니다.

RTT에는 두 가지 종류가 존재합니다.
- Sample RTT: 각 segment에서 측정된 RTT, network 상황에 따르기 때문에 매우 다양한 값으로 존재
- Estimated RTT: EWMA로 측정한 RTT (smoothed value)

위 값들로 n번째 RTT를 추정하면: <br>
$$
EstimatedRTT(n) = (1 - \alpha) \times EstimatedRTT(n - 1) + \alpha \times SampleRTT(n)
$$ <br>
($\alpha$는 보통 0.125)

$\alpha$를 작게 할수록 RTT가 더 smooth해지고, 크게 할수록 sample에 가까워집니다.

TCP에서는 연결마다 하나의 RTT 값만을 측정하고 관리합니다.
- GBN & TCP: 가장 오래된 unACKed segment에 대한 timer
- 대부분의 TCP implementation: 하나의 RTT만을 측정 (이미 timer를 사용하고 있다면 무시)

---

**Safety margin**은 네트워크가 급격하게 변화해도 안정적으로 동작할 수 있도록 합니다. 이때 **DevRTT**를 통해 RTT의 variability를 측정하고, 만약 EstimatedRTT와 SampleRTT 간의 차이가 크면 RTT 변동성이 큰 것을 확인하고 DevRTT 값이 커지고 더 큰 safety margin을 확보하게 됩니다.

$$
DevRTT(n) = (1 - \beta) \times DevRTT(n - 1) + \beta \times |SampleRTT(n) - EstimatedRTT(n)|
$$

---

이렇게 위에서 추정한 RTT 값들로 TCP timeout interval을 설정하게 됩니다.

$$
TimeoutInterval(n) = EstimatedRTT(n) + 4 \times DevRTT(n)
$$